Instructions for building and running the PDDL MDP simulator
------------------------------------------------------------
John Asmuth, Michael L. Littman, and Håkan L. S. Younes

This package has been prepared with the GNU build tools.  See
`INSTALL' for generic instruction on how to build the MDP simulator.

On most systems you should be able to build the server and a simple
client in two easy steps:

1. Type `./configure' to configure the package for your system.

2. Type `make' to compile the package.

If all goes well, this should produce two executables: the server
`mdpsim' and a simple client `mdpclient'.

Run `./mdpsim --help' for brief information on how to run the MDP
server.

To test, first start a server:

  ./mdpsim --port=2323 --config=comp.cfg examples/john.pddl &

Next, start a simple client:

  ./mdpclient 0:2323 examples/john.pddl john-problem

The client should print information on the simulation runs and exit.
To stop the server, kill the associated process.


Troubleshooting
---------------

The package has been successfully compiled on the following platforms
using various versions of GCC:

  RedHat Linux 6.2, 7.1, 9.0
  SunOS 5.5, 5.7, 5.9
  IRIX 6.5

If you encounter problems when compiling the package, send the output
produced by the configure script and the output generated by make to
<lorens@cs.cmu.edu>.


Interpreting the test output
----------------------------

The server tests the sample planner (mdpclient, which executes random
legal actions) on the domain defined in the file examples/john.pddl on
the problem `john-problem' defined there.  It executes the domain
twice---this parameter is set in the configuration file comp.cfg (the
second number on the first line).

Here is an example output (newlines added for clarity):

<end-round>
 <state>
  <atom><predicate>has-soap</predicate></atom>
  <atom><predicate>has-soccer-ball</predicate></atom>
  <atom><predicate>shower-is-on</predicate></atom>
  <fluent><function>reward</function><value>14</value></fluent>
 </state>
 <time-spent>3</time-spent>
 <turns-used>5662</turns-used>
</end-round>

<end-round>
 <state>
  <atom><predicate>has-soap</predicate></atom>
  <atom><predicate>has-soccer-ball</predicate></atom>
  <fluent><function>reward</function><value>-30</value></fluent>
 </state>
 <time-spent>3</time-spent>
 <turns-used>7861</turns-used>
</end-round>

<end-session>
 <sessionID>62</sessionID>
 <problem>john-problem</problem>
 <rounds>2</rounds>
 <goals>
  <failed>2</failed>
  <reached><successes>0</successes></reached>
 </goals>
 <metric-average>-8</metric-average>
</end-session>

It shows the final state of two rounds for this domain (positive
literals are listed).  It also reports the reward value for each
round, the time spent, and the number of steps taken.  A final report
gives the average value of the reward score ((+14-30)/2 = -8) as well
the number of successful vs. unsuccessful rounds.


Communication Protocol
----------------------

Upon connecting to the server, the client issues a message of the form
<session-request>
 <name> -some arbitrary identifier- </name>
 <problem> -the name of the problem to work on- </problem>
</session-request>

the server will respond with
<session-init>
 <sessionID> -some number- </sessionID>
 <setting>
  <rounds> -the times you can try the problem- </rounds>
  <allowed-time> -time limit- </allowed-time>
  <allowed-turns> -turn limit- </allowed-turns>
 </setting>
</session-init>

the client will then send
<round-request/>

to which the server responds
<round-init>
 <round> -the count of how many rounds you've done- </round>
 <sessionID> -that same  number- </sessionID>
</round-init>

at this point the client may do any calculations, as the clock is running.

the server will give states like this
<state>
 <is-goal/> (this will only appear if the goal has been met)
 -atoms-
 -fluents-
</state>

an atom
<atom>
 <predicate> -the name of the predicate- </predicate>
 <term> -a term- </term>  (0 or more of these)
 <term> -another term- </term>
</atom>

a fluent
<fluent>
 <function> -the name of the function- </function>
 <term> -a term- </term>  (0 or more of these)
 <term> -another term- </term>
 <value> -fluent value- </value>
</fluent>

the client responds with actions
<act>
 <action>
  <name> -the name of the action- </name>
  <term> -a term- </term>  (0 or more of these)
  <term> -another term- </term>
 </action>
</act>


Conversion to ADD/MTBDD Representation
--------------------------------------

The file `mtbdd.cc' contains code for constructing ADD/MTBDD
representations of transition probability matrices and reward vectors
for PPDDL actions.  The code uses the CUDD package for decision
diagram manipulation, which can be obtained at the following location:

  http://vlsi.colorado.edu/~fabio/  

You can build a simple client program that uses the converter with
`make mtbddclient', but before doing so you need to install the CUDD
link libraries and headers in a single directory and configure the
package with the following command:

  ./configure CUDDDIR=<location of cudd files>

The default value of CUDDDIR is `./cudd'.

To set up CUDD, try the following:

  wget ftp://vlsi.colorado.edu/pub/cudd-2.3.1.tar.gz
  gunzip cudd-2.3.1.tar.gz 
  tar xvf cudd-2.3.1.tar
  ln -s cudd-2.3.1/cudd
  cd cudd-2.3.1
  [hand-edit the makefile]
  make

To test the MTBDD client, first start a server:

  ./mdpsim --port=2323 --config=comp.cfg examples/coffee-domain.pddl coffee-problem.pddl &

Next, start the client:

  ./mtbddclient -v1 --host=0 --port=2323 examples/coffee-domain.pddl coffee-problem.pddl

You can increase the verbosity level by using -v2 or -v3 instead of
-v1.  This will provide more detailed output from the conversion to
MTBDDs and the progress of value iteration.
